(* Lockstitch's KDF expansion and authenticated encryption is IND-CPA. *)

(* AEGIS-128L is assumed to be a secure AEAD when used with a unique nonce. *)

proba Penc.
proba Pencctxt.

type key [fixed].

expand AEAD(key, bitstring, bitstring, bitstring, enc, dec, injbot, Z, Penc, Pencctxt).

(* HKDF-SHA-256-Extract is assumed to be a random oracle. *)

type hash_key [fixed].
type transcript [bounded, large, nonuniform].
type prk [fixed, large].

expand ROM_hash(hash_key, transcript, prk, kdf_extract, Okdf_extract, qKDFextract).

(* HKDF-SHA-256-Expand is assumed to be a PRF. *)

type info [fixed].
const info1: info.

proba Pkdf.

expand PRF(prk, info, key, kdf_expand, Pkdf).

(* Construction *)

(* No associated data is used with AEGIS-128L. *)
const ad: bitstring.

letfun full_enc(m: bitstring, hk: hash_key, t: transcript) =
    prk1 <- kdf_extract(hk, t);
    k1 <- kdf_expand(prk1, info1);
    enc(m, ad, k1).

(* Queries *)

param qEnc.

query secret b [cv_bit].

let QencLR(b0: bool, hk: hash_key, t: transcript) = 
    foreach i <= qEnc do
        Oenc (m1: bitstring, m2: bitstring) :=
        if Z(m1) = Z(m2) then (* m1 and m2 have the same length *)
        m0 <- if b0 then m1 else m2;
        return(full_enc(m0, hk, t)).

process 
    Ostart() :=
    b <-R bool;
    hk <-R hash_key;
    t <-R transcript;
    return;
    (run QencLR(b, hk, t) | run Okdf_extract(hk))