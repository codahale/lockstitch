(* Lockstitch's KDF expansion and authenticated encryption is INT-CTXT. *)

(* AEGIS-128L is assumed to be a secure AEAD when used with a unique nonce. *)

proba Penc.
proba Pencctxt.

type key [fixed].

expand AEAD(key, bitstring, bitstring, bitstring, enc, dec, injbot, Z, Penc, Pencctxt).

(* TurboSHAKE128 is assumed to be a random oracle. *)

type hash_key [fixed].
type transcript [bounded, large, nonuniform].
type hash [fixed, large].

expand ROM_hash(hash_key, transcript, hash, kdf_extract, Okdf_extract, qKDFextract).

(* TurboSHAKE128's XOF is assumed to be a PRF. *)

type info [fixed].
const info1: info.

proba Pkdf.

expand PRF(hash, info, key, kdf_expand, Pkdf).

(* Construction *)

(* No associated data is used with AEGIS-128L. *)
const ad: bitstring.

letfun full_enc(m: bitstring, hk: hash_key, t: transcript) =
    h1 <- kdf_extract(hk, t);
    k1 <- kdf_expand(h1, info1);
    enc(m, ad, k1).

letfun full_dec(c: bitstring, hk: hash_key, t: transcript) =
    h1 <- kdf_extract(hk, t);
    k1 <- kdf_expand(h1, info1);
    dec(c, ad, k1).

(* Queries *)

param qEnc, qDec.

event bad.
query event(bad) ==> false.

table ciphertexts(bitstring).
 
let Qenc(hk: hash_key, t: transcript) = 
    foreach ienc <= qEnc do
        OEnc(m0: bitstring) :=
            c0 <- full_enc(m0, hk, t);
            insert ciphertexts(c0);
            return(c0).

let QdecTest(hk: hash_key, t: transcript) =
    foreach idec <= qDec do
        ODec(c: bitstring) :=
            get ciphertexts(=c) in return(true) else
                if full_dec(c, hk, t) <> bottom
                then event bad; return(true)
                else return(false).

process 
    Ostart() :=
    hk <-R hash_key;
    t <-R transcript;
    return;
    (run Qenc(hk, t) | run QdecTest(hk, t) | run Okdf_extract(hk))